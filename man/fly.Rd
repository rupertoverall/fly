% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fly.R
\name{fly}
\alias{fly}
\title{Intuitive Iteration with Clean Syntax}
\usage{
fly(
  X,
  expr,
  ...,
  .var = ".x",
  .margin = 1,
  .parallel = NULL,
  .index_var = ".i",
  simplify = FALSE
)
}
\arguments{
\item{X}{The data object to iterate over. Can be a list, vector, matrix,
array, or data frame.}

\item{expr}{An expression or function to execute for each element. Can be a
code block in braces, a function name, or a function object.}

\item{...}{Additional arguments passed to the function when \code{expr} is a
function, or made available as variables when \code{expr} is an expression.}

\item{.var}{Name of the variable in which each input element is stored. Default is
\code{".x"}.}

\item{.margin}{For matrix/array inputs, specifies whether to iterate over
rows (1) or columns (2). Default is 1 (rows).}

\item{.parallel}{Optional parallel processing. Either a number specifying the
number of cores to use, or a cluster object from the \code{parallel}
package. Default is \code{NULL} (sequential processing).}

\item{.index_var}{Name of the variable in which the current iteration index is stored.
Default is \code{".i"}. Set to \code{NULL} or empty string to disable.}

\item{simplify}{Logical or character string; should the result be simplified
to a vector, matrix or higher dimensional array if possible? For
\code{sapply} it must be named "array". Default is \code{FALSE} (always
return a list).}
}
\value{
By default, returns a list. When \code{simplify = TRUE}, attempts to
  simplify to a vector or array like \code{sapply}. Names from the original
  data object are preserved when present.
}
\description{
The \code{fly} function provides an intuitive way to iterate over data
objects with clean, readable syntax. It supports various input types
including lists, vectors, matrices, and data frames, with optional parallel
processing and result simplification.
}
\details{
\code{fly} is essentially a wrapper for \code{lapply} but which conbines the
simplicity of a \code{for} loop while retaining the flexibilty and power of
\code{lapply}. The basic syntax is intuitive and requires much less typing
than \code{lapply}---especially for typical use cases.

Some handy features are included:
\itemize{
 \item Custom functions do not need the \code{function} keyword, just insert the body of the function as a code block.
 \item The variable holding the data for each iteration does not need to be declared. By default it is ".x".
 \item The index of the iteration is automatically made available as a variable. By default called ".i".
 \item Element names (from the input list or matrix) are used to name the output list.
 \item Output is always a list (including empty elements) so it will always align with the input.
 \item Parallelisation is built-in. No need to interface with the \code{parLapply} syntax directly. The same code will work sequentially or in parallel by just changing one parameter.
 \item Lists and matrices use the same function.
 }

The \code{fly} function supports several input types:
\itemize{
  \item \strong{Lists}: Iterates over list elements
  \item \strong{Vectors}: Converts to list and iterates over elements
  \item \strong{Matrices/Arrays}: Iterates over rows or columns based on \code{.margin}
  \item \strong{Data frames}: Iterates over columns (like \code{lapply})
}

The function can execute either expressions (code blocks) or functions:
\itemize{
  \item \strong{Expressions}: Use braces \code{\{...\}} to write code that has
    access to the iteration variable (default \code{.x}) and any additional arguments
  \item \strong{Functions}: Pass function names or objects that will be called
    with each element plus any additional arguments
}

The \code{simplify} parameter works exactly like in \code{sapply}:
\itemize{
  \item \code{FALSE}: Always return a list (default)
  \item \code{TRUE}: Simplify to vector/matrix when possible
  \item \code{"array"}: Simplify to array when possible
}
}
\examples{
# Basic list iteration
data <- list(a = 1:4, b = 5:8)
result <- fly(data, sum)
print(result)

# Using expressions with default .x variable
result <- fly(data, { length(.x) })
print(result)

# With additional arguments
text_data <- list(a = c("hello", "world"), b = c("foo", "bar"))
result <- fly(text_data, { paste(.x, collapse = sep) }, sep = "-")
print(result)

# Matrix iteration by rows (default)
mat <- matrix(1:12, nrow = 3)
rownames(mat) <- paste0("row", 1:3)
result <- fly(mat, sum)
print(result)

# Matrix iteration by columns
result <- fly(mat, mean, .margin = 2)
print(result)

# Custom variable name
result <- fly(data, { row_sum <- sum(row_data); row_sum^2 }, .var = "row_data")
print(result)

# Accessing iteration index
result <- fly(data, { paste("Item", .i, "sum:", sum(.x)) })
print(result)

# Simplify results
numbers <- list(a = 1:3, b = 4:6, c = 7:9)
result_list <- fly(numbers, sum)                    # Returns list
result_vector <- fly(numbers, sum, simplify = TRUE) # Returns named vector
print(result_list)
print(result_vector)

# Parallel processing
\dontrun{
large_list <- as.list(1:100)
result <- fly(large_list, { Sys.sleep(0.01); .x^2 }, .parallel = 4)
}

}
\seealso{
\code{\link{lapply}}, \code{\link{sapply}}, \code{\link{apply}}
}
